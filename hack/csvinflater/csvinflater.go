// csvinflater adds additional information to the ClusterServiceVersion (CSV) resource. The CSV is the package format
// for the Operator Framework.
//
// This program collects information from our operator sources and writes a kustomize patch for the CSV generated by
// operator-sdk. In particular, it:
// * Annotates all CustomResourceDefinitions with the type of k8s resource it controls.
// * Annotates the CSV with all the kubernetes native resource version it expects.
package main

import (
	"embed"
	"fmt"
	"log"
	"sort"

	"github.com/cert-manager/cert-manager/pkg/apis/certmanager"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/kustomize/api/krusty"
	"sigs.k8s.io/kustomize/api/resmap"
	kusttypes "sigs.k8s.io/kustomize/api/types"
	"sigs.k8s.io/kustomize/kyaml/resid"
	"sigs.k8s.io/yaml"

	piraeusv1 "github.com/piraeusdatastore/piraeus-operator/v2/api/v1"
	"github.com/piraeusdatastore/piraeus-operator/v2/pkg/resources"
	"github.com/piraeusdatastore/piraeus-operator/v2/pkg/resources/cluster"
	"github.com/piraeusdatastore/piraeus-operator/v2/pkg/resources/satellite"
	"github.com/piraeusdatastore/piraeus-operator/v2/pkg/utils"
)

func main() {
	clusterRes, err := CombineAllEmbededResources(&cluster.Resources)
	if err != nil {
		log.Fatalf("failed to load cluster resources: %s", err)
	}

	satelliteRes, err := CombineAllEmbededResources(&satellite.Resources)
	if err != nil {
		log.Fatalf("failed to load satellite resources: %s", err)
	}

	patch := []utils.JsonPatch{
		{
			Op:    utils.Add,
			Path:  "/spec/nativeAPIs",
			Value: GetNativeAPI(append(clusterRes.AllIds(), satelliteRes.AllIds()...)...),
		},
		{
			Op:    utils.Test,
			Path:  "/spec/customresourcedefinitions/owned/0/kind",
			Value: "LinstorCluster",
		},
		{
			Op:    utils.Test,
			Path:  "/spec/customresourcedefinitions/owned/1/kind",
			Value: "LinstorNodeConnection",
		},
		{
			Op:    utils.Test,
			Path:  "/spec/customresourcedefinitions/owned/2/kind",
			Value: "LinstorSatelliteConfiguration",
		},
		{
			Op:    utils.Test,
			Path:  "/spec/customresourcedefinitions/owned/3/kind",
			Value: "LinstorSatellite",
		},
	}

	bytes, err := yaml.Marshal(patch)
	if err != nil {
		log.Fatalf("failed to marshal patch: %s", err)
	}

	fmt.Println("# File generated by csvinflater. DO NOT EDIT.")
	fmt.Print(string(bytes))
}

func CombineAllEmbededResources(fs *embed.FS) (resmap.ResMap, error) {
	kustomizer, err := resources.NewKustomizer(fs, krusty.MakeDefaultOptions())
	if err != nil {
		return nil, fmt.Errorf("failed to create kustomizer: %w", err)
	}

	subDirs, err := fs.ReadDir(".")
	if err != nil {
		return nil, fmt.Errorf("failed to list embedded directories: %w", err)
	}

	var subDirNames []string
	for i := range subDirs {
		if subDirs[i].Name() == "patches" {
			continue
		}

		subDirNames = append(subDirNames, subDirs[i].Name())
	}

	return kustomizer.Kustomize(&kusttypes.Kustomization{
		Resources: subDirNames,
	})
}

func GetNativeAPI(rs ...resid.ResId) []metav1.GroupVersionKind {
	allGvk := make(map[string]struct{})
	for _, r := range rs {
		if r.Group == piraeusv1.GroupVersion.Group {
			continue
		}

		if r.Group == certmanager.GroupName {
			continue
		}

		allGvk[r.Gvk.String()] = struct{}{}
	}

	result := make([]metav1.GroupVersionKind, 0, len(allGvk))
	for k := range allGvk {
		gvk := resid.GvkFromString(k)
		result = append(result, metav1.GroupVersionKind{
			Group:   gvk.Group,
			Version: gvk.Version,
			Kind:    gvk.Kind,
		})
	}

	sort.Slice(result, func(i, j int) bool {
		if result[i].Group != result[j].Group {
			return result[i].Group < result[j].Group
		}
		if result[i].Version != result[j].Version {
			return result[i].Version < result[j].Version
		}
		return result[i].Kind < result[j].Kind
	})

	return result
}
